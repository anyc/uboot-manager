#! /bin/bash
#
# Source: https://github.com/anyc/uboot-manager
# License: GPLv2
#
# Written by Mario Kicherer (http://kicherer.org)
#

. /etc/uboot.cfg

UBM_ENV_FILE=$(mktemp)

# default values
UBM_ROOT_PART=${UBM_ROOT_PART-/dev/mmcblk0p2}
UBM_KERNEL_ARGS=${UBM_KERNEL_ARGS-rootfstype=btrfs quiet splash logo.nologo}
UBM_MENU_TIMEOUT=${UBM_MENU_TIMEOUT-2}
UBM_DEFAULT=${UBM_DEFAULT-boot0}
UBM_PREPEND_FW_KERNEL_ARGS=${UBM_PREPEND_FW_KERNEL_ARGS-1}
UBM_PRELOADED_DEVTREE=${UBM_PRELOADED_DEVTREE-0}
UBM_DEVTREE_FILE=${UBM_DEVTREE_FILE-bcm2709-rpi-2-b.dtb}
UBM_INITRD_LADDR_ID=${UBM_INITRD_LADDR_ID-ramdisk_addr_r}
UBM_KERNEL_LADDR_ID=${UBM_KERNEL_LADDR_ID-kernel_addr_r}
UBM_KERNEL_DIR=${UBM_KERNEL_DIR-/boot}

# check if mkimage tool is installed
command -v mkimage >/dev/null || { echo "missing mkimage"; exit 1; }

if [ -d /etc/uboot.cfg.d/ ]; then
	for script in /etc/uboot.cfg.d/*; do
		[[ -x "${script}" ]] && source "${script}"
	done
fi

echo -n "" > "${UBM_ENV_FILE}"


# override boot procedure by GPIO state?
if [ "${UBM_FAILSAFE_GPIO_PIN}" != "" ]; then
	# if GPIO pin is high, execute command
	echo "if gpio input ${UBM_FAILSAFE_GPIO_PIN}; then ; else setenv stdout serial,lcd ; echo \"failsafe pin set\"; ${UBM_FAILSAFE_COMMAND}; fi" >> "${UBM_ENV_FILE}"
fi

# override U-Boot output
if [ "${UBM_STDOUT}" != "" ]; then
	echo "setenv stdout ${UBM_STDOUT}" >> "${UBM_ENV_FILE}"
fi

# override device tree?
if [ "${UBM_PRELOADED_DEVTREE}" == "0" ]; then
	if [ "${UBM_DEVTREE_FILE}" != "" ]; then
		echo "fatload mmc 0:1 \${fdt_addr} ${UBM_DEVTREE_FILE}" >> "${UBM_ENV_FILE}"
	fi
else
	# check if device tree is available in memory. If yes, get bootargs set by
	# firmware and store them in $fw_bootargs. If not, load the device tree file
	# into memory for safety and backwards compatibility
	echo -n "if fdt addr \${fdt_addr}; then fdt get value fw_bootargs /chosen bootargs; printenv fw_bootargs; " >> "${UBM_ENV_FILE}"
	if [ "${UBM_DEVTREE_FILE}" != "" ]; then
		echo -n "else fatload mmc 0:1 \${fdt_addr} ${UBM_DEVTREE_FILE}; "  >> "${UBM_ENV_FILE}"
	else
		echo -n "echo 'preloaded device tree not found'" >> "${UBM_ENV_FILE}"
	fi
	echo    "fi;" >> "${UBM_ENV_FILE}"
fi

# set default kernel args
if [ "${UBM_PREPEND_FW_KERNEL_ARGS}" == "1" ]; then
	# do not append fw_bootargs as it contains rootfstype=ext4
	echo "setenv bootargs \"\${fw_bootargs} root=${UBM_ROOT_PART} rw rootwait ${UBM_KERNEL_ARGS}\"" >> "${UBM_ENV_FILE}"
else
	echo "setenv bootargs \"root=${UBM_ROOT_PART} rw rootwait ${UBM_KERNEL_ARGS}\"" >> "${UBM_ENV_FILE}"
fi

# menu header
echo "echo ' '
echo 'Available boot options:'
echo '-----------------------'" >> "${UBM_ENV_FILE}"


# callback for each kernel
function vmlinuz_cb() {
	kernel=$1
	version=$2
	
	echo -n "Found kernel ${kernel}"
	echo "" >> "${UBM_ENV_FILE}"
	
	if [ -f ${UBM_KERNEL_DIR}/initrd.img-${version} ] || [ -f ${UBM_KERNEL_DIR}/initrd.uimg-${version} ]; then
		echo " with initrd"
		UBM_INITRD=\${${UBM_INITRD_LADDR_ID}}
		PRECMDS="${PRECMDS}fatload mmc 0:1 \${${UBM_INITRD_LADDR_ID}} initrd.uimg-${version}; "
		
		if [ ! -f ${UBM_KERNEL_DIR}/initrd.uimg-${version} ]; then
			echo "Creating U-Boot image for ${UBM_KERNEL_DIR}/initrd.img-${version}"
			mkimage -n "Ramdisk Image ${version}"  -A arm -O linux -T ramdisk -C gzip -d ${UBM_KERNEL_DIR}/initrd.img-${version} ${UBM_KERNEL_DIR}/initrd.uimg-${version} || { echo "error creating initrd.uimg"; exit 1; }
		else
			echo "Using cached U-Boot image for ${UBM_KERNEL_DIR}/initrd.img-${version}"
		fi
	else
		echo ""
		UBM_INITRD=-
	fi
	
	if [ -f ${UBM_KERNEL_DIR}/cmdline-${version} ]; then
		echo "setenv bootargs${i} 'setenv bootargs \"$(cat ${UBM_KERNEL_DIR}/cmdline-${version} | tr '\n' ' ' | sed "s/[[:space:]]*$//")\"'" >> "${UBM_ENV_FILE}"
		PRECMDS="${PRECMDS}run bootargs${i}; "
	fi
	
	echo "setenv boot${i} '${PRECMDS}fatload mmc 0:1 \${${UBM_KERNEL_LADDR_ID}} ${kernel}; bootz \${${UBM_KERNEL_LADDR_ID}} ${UBM_INITRD} \${fdt_addr}'" >> "${UBM_ENV_FILE}"
	
	echo "echo '   \"run boot${i}\" will boot ${kernel}'" >> "${UBM_ENV_FILE}"
}

# register callback
UBM_KERNEL_FCTS="${UBM_KERNEL_FCTS} vmlinuz_cb"

pushd ${UBM_KERNEL_DIR} >/dev/null
	# look for kernels and execute callbacks
	i=0
	shopt -s nullglob
	FILES=$(ls -vr vmlinuz* zImage* Image* xipImage* uImage*)
	shopt -u nullglob
	for k in $FILES; do
		[ -e "$k" ] || continue
		
		PRECMDS=""
		kernel=$(basename "${k}")
		version=$(basename "${k}" | cut -d "-" -f2-)
		
		# execute all registered callbacks for this kernel
		for cb in ${UBM_KERNEL_FCTS}; do
			${cb} ${kernel} ${version}
		done
		
		i=$(( $i + 1 ))
	done
	echo "echo ' '" >> "${UBM_ENV_FILE}"
popd >/dev/null

# do we alter boot procedure if failsafe file does not exist?
if [ "${UBM_FAILSAFE_FILE}" != "" ]; then
	# if file exists, execute command, else create file
	echo "if test -e mmc 0:1 ${UBM_FAILSAFE_FILE}; then setenv stdout serial,lcd ; echo \"failsafe file ${UBM_FAILSAFE_FILE} present\"; ${UBM_FAILSAFE_COMMAND}; else fatwrite mmc 0:1 0x02050000 ${UBM_FAILSAFE_FILE} 1; fi" >> "${UBM_ENV_FILE}"
fi

echo "
setenv autoboot run distro_bootcmd

echo 'Will execute \"run ${UBM_DEFAULT}\" in ${UBM_MENU_TIMEOUT} seconds, abort with CTRL+c...'
sleep ${UBM_MENU_TIMEOUT} && run ${UBM_DEFAULT}
" >> "${UBM_ENV_FILE}"

# create an image from the script in a format uboot understands
echo "Building uboot-manager script..."
mkimage -A arm -O linux -T script -C none -a 0x00000000 -e 0x00000000 -n "uboot-manager" -d "${UBM_ENV_FILE}" ${UBM_KERNEL_DIR}/boot.scr || { echo "error creating uboot-manager script image"; exit 1; }

#cat "${UBM_ENV_FILE}"
rm "${UBM_ENV_FILE}"
